# Lab 5

## 知识点

这些是与本实验有关的原理课的知识点：

* 进程状态模型
* 用户进程

此外，本实验还涉及如下知识点：

* ELF文件格式
* 写时复制

遗憾的是，如下知识点在原理课中很重要，但本次实验没有很好的对应：

* 挂起的进程

## 练习0

首先，需要对之前的代码进行微小的修改：

1. `alloc_proc`加入对新增字段的初始化，由于我使用`memset`初始化，不需要修改
2. `do_fork`时设置对父进程的指针
3. `do_fork`时将进程插入进程链表、增加进程计数器的操作，替换为`set_links`函数，该函数不仅有上面两个操作，还设置了进程间的关系指针
4. `ticks % TICK_NUM == 0`时，将打印提示信息替换为将当前进程的`need_resched`置1，表明当前进程时间片已耗尽，需要运行调度器

## 练习1

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。主要就是修改`load_icode`，补上对`trapframe`结构体的初始化。初始化的核心是`eip`以及`esp`。`eip`需要设为ELF映像中定义的入口点，`esp`则设为用户栈顶，由于开启了分页，它只需要设置为一个常数，为用户栈顶的虚拟地址`USTACKTOP`。

当创建一个用户态进程并加载了应用程序，并且内核调度器选择此进程开始执行，过程为：

1. `proc_run`被调用，`current`被置为此进程控制块的指针，标志着此进程成为运行状态
2. 加载内核栈和页表
3. `switch_to`被调用，由于当前进程的`context`的`eip`被置为`forkret`，`switch_to`最终跳转到`forkret`
4. `forkret`进而跳转到`__trapret`，这段代码是进入用户态的关键
5. `__trapret`首先根据当前进程的`trapframe`结构体“恢复”（加载）内核新构造的中断上下文，最后使用`iret`指令同时完成跳转到用户进程入口点、切换到用户栈以及切换到用户态的操作

具体而言，处理器在执行`iret`指令时，当前栈的布局是这样的：

```
|  high address  |
------------------
|   SS (ring3)   |
------------------
|       ESP      |
------------------
|     EFLAGS     |
------------------
|   CS (ring3)   |
------------------
|       EIP      |  <---- ESP, CS=ring0
------------------
|  low  address  |
```

当处理器发现栈中的`CS`为ring3，它在弹出`EFLAGS`之后还会弹出`SS`和`ESP`，并将它们赋给相应寄存器。

至此，处理器的`iret`指令就同时完成了跳转到用户进程入口点、切换到用户栈以及切换到用户态的操作。

我的实现和参考答案十分一致。

## 练习2

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。需要补充的地方是`copy_range`函数中拷贝内存和将页面映射信息填入页表的实现。

值得说明的是，我最初实现时手动填写了页表项，而没有调用`page_insert`，可能会造成引用计数维护错误，后来自己发现并修复了。

我的实现和参考答案十分一致。

写时复制的设计与实现请见下面的小节。

## 练习3

**fork**

`fork`创建了一个新的进程控制块，此时进程为UNINIT，然后将当前进程几乎所有信息复制到了新的进程。没有复制的信息包括内核栈和用于存放返回值的`eax`寄存器，它们都是新的。

在`wakeup_proc`被调用之后，进程状态变为RUNNABLE的就绪态。

**exec**

`exec`先将当前进程的内存布局（  `mm`结构体）清除干净，然后调用`load_icode`填写目标ELF映像中说明的内存布局。注意，进程的状态不发生变化。

**wait**

这个系统调用涉及两个进程，当前进程及其子进程。`wait`首先检查当前进程是否有子进程，若无则直接返回错误。接着，检查是否有ZOMBIE状态的子进程，若有则直接释放子进程残存的资源，然后立即返回子进程的返回状态码，此时子进程已不存在。

若没有ZOMBIE状态的子进程，此进程变为SLEEPING状态，等待这样的子进程出现，再进行上面的操作。

**kill**

这里的`kill`实现不是发信号，而是将指定进程的标记为设为EXITING，在下一次中断来临时，让进程调用`exit`来自己杀死自己，从而变成ZOMBIE状态。

**exit**

这个系统调用涉及两个进程，当前进程及其父进程。`exit`会清除当前进程几乎所有资源，除了进程控制块以及内核栈，接着将其所有子进程的父进程置为init进程，然后将当前进程的状态变为ZOMBIE。若该进程有父进程，并且父进程正在等待子进程退出，则将父进程的状态从SLEEPING变为RUNNABLE态。

总结成状态转移图如图所示：

```
  ?               RUNNING
  |                A    |
  |                |    |
 (1)              (3)  (4)
  |                |    |
  V                |    V
UNINIT -- (2) --> RUNNABLE -- (7) --> ZOMBIE -- (8) --> ?
                    A   |
                    |   +--- (5) --> SLEEPING --+
                    |                           |
                    +----------- (6) -----------+
```

(1) `alloc_proc`

(2) `wakeup_proc`

(3) `proc_run`被调用时，作为`proc_run`的参数

(4) `proc_run`被调用时，作为`proc_run`的调用者

(5) 调用了`wait`（或`sleep`，上面没有涉及）

(6) 子进程调用了`exit`（或定时器超时，上面没有涉及）

(7) 调用了`exit`

(8) 父进程调用了`wait`

## 扩展练习 - 写时复制

TODO

这个不一致性告诉内核，这个是一个需要写时复制的页面，它可能正在和其它进程共享（如果页面引用计数大于1）。

我将函数`share`参数的语义定义为是否用写时复制的方式实现内存的复制。

不过，我的实现没有考虑挂起的情况。