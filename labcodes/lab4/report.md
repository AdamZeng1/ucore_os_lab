# Lab 4

## 知识点

这些是与本实验有关的原理课的知识点：

* 进程状态模型
* 内核线程的控制

此外，本实验还涉及如下知识点：

* `proc`结构体及其`context`结构体的理解

遗憾的是，如下知识点在原理课中很重要，但本次实验没有很好的对应：

* 用户进程

## 练习1

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。

要实现的就是`alloc_proc`，分配一块小内存作为进程控制块，然后对其初始化。初始化操作主要是将其他字段（使用`memset`）清零，然后对特定字段，如`pid`、`cr3`等进行初始化。由于本实验是内核线程，`cr3`可以初始化为当前`cr3`（利用`rcr3`）。

与参考答案对比，我的实现使用`memset`，而参考答案对每一个字段逐一初始化。参考答案的语义更清晰，而我的性能可能会稍好一些。另外，我没有初始化`pid`为-1，在某些情况下可能出问题，应修复。此外，参考答案直接使用`boot_cr3`而不需要利用`rcr3`。

**对于`trapframe`结构体和`context`结构体的理解**



## 练习2

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可，主要实现`do_fork`。

对于`pid`的分配，内核在`do_fork`中通过调用`get_pid`分配一个新的`pid`然后赋值给新分配的进程。下面分析`get_pid`的算法。

算法主要使用两个变量：`next_safe`以及`last_pid`。注意到它们被声明为`static`，效果类似于全局变量。首先，算法初始化`next_safe`以及`last_pid`均为`MAX_PID`，这是合法`pid`的上界加一。

算法首先将`last_pid`增加1（特别地，若达到或超过`MAX_PID`则回到1，并认为此时`last_pid`超过了`next_safe`），此时若是仍然小于当前`next_safe`，则立即分配当前`last_pid`，本次算法结束。否则，此时说明`last_pid`已到达甚至超过`next_safe`，需要重新计算`next_safe`了。

为了接下来描述方便，假设所有未被分配的`pid`组成一段一段区间，叫做空闲`pid`区间。

计算`next_safe`的主要过程是一个循环，循环内有两个操作“同时”进行：

1. 寻找`last_pid`的下一个合法值，即大于`last_pid`的最近的区间的下界，存于`last_pid`。注意，若`last_pid`被更新，`next_safe`需要重新开始计算。
2. 寻找当前`last_pid`所在空闲`pid`区间的上界加一，即已被分配的`pid`中大于`last_pid`的最小的那一个，存于`next_safe`。

总之，`last_pid`维护了最新分配出去的`pid`，而`next_safe`维护了`last_pid`所在空闲`pid`区间的上界加一。

这样就保证了每一次`get_pid`分配出来的`pid`没有其他进程正在使用，而且分配效率很高。从这里也看出，需要先分配`pid`，然后再将进程插入链表，否则算法会混乱。

与参考答案对比，在分配`pid`、将进程插入链表和散列表时涉及到对共享变量的操作，参考答案用关中断的方法把共享变量保护了起来，而我没有这么做，应修复。另外，对于多核处理器，应该使用其他手段，因为关中断不能确保其他处理器的互斥访问了。

## 练习3

内核调用`proc_run`之后，TODO