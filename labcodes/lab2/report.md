# Lab 2

## 知识点

这些是与本实验有关的原理课的知识点：

* 首次匹配
* x86分页机制
* 二级页表

此外，本实验还涉及如下知识点：

* 内核实现的通用链表

遗憾的是，如下知识点在原理课中很重要，但本次实验没有很好的对应：

* 最佳匹配
* 最差匹配
* 碎片整理技术
* 反置页表

## 练习1

实验代码已经提供了某种连续内存分配算法，为实现首次匹配，需要修改代码，维护`free_list`有如下性质：

1. 链表中的页面块均为空闲
2. 每个空闲页面块首个页面挂在链表中，对应的`Page`结构体有属性，为页面块的页面数；该页面块其余页面不直接挂在链表中，也没有属性，属性值的位置清零
3. 链表中页面块按照首地址增序排列

### 对于`default_alloc_pages`函数的修改

需要修改`default_alloc_pages`函数来维护上面的性质，但改动不大。

主要修改就是将新分裂出来的页面块（若有）设置好属性并插入正确的位置，而不是直接插入到`free_list`最后。

正确的位置实际上就是原页面块原来位置的后一项。实现上，可以先将新分裂出的页面块插入，再将分配出去的页面块移出。

### 对于`default_free_pages`函数的修改

还需要修改`default_free_pages`函数来维护上述性质，但改动不大。

在重新设置页面属性、合并相邻页面后，需要将该页面插入到链表正确的位置中，也就是将原来的`list_add(&free_list, &(base->page_link));`替换为一个循环，根据页面首地址找到正确的位置然后插入。

### 改进

这个分配算法还可能继续优化，优化可能有如下几点：

1. 释放时的合并操作，在查找与该空闲块相邻的下一个块时不需要循环遍历查找，只需要根据当前块的页面数计算出来即可，接着判断下一个页面块是否空闲，然后尝试合并
2. 释放时的合并操作，若是在所有页面块最后一个页面处也记录这个页面块的页面数，则在查找与该新释放出的空闲块相邻的上一个块时也不需要循环遍历查找，只需要根据上一块的页面数计算出来即可，接着判断是否空闲，然后尝试合并
3. 源于这样一个简单的想法：上次成功的地方之后还可能有空闲块。因此，查找空闲块时从上一次成功分配的块开始查找，直到链表末尾，然后卷回链表起始继续查找，直到重新回到上一次成功的位置，用循环链表实现非常简单。这其实是下一次适配。

与参考答案对比，我认为我的实现对原来实验代码的修改较小，思路清晰，实现简洁。

## 练习2

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。

这个练习主要是页目录项的填写，页目录项的字段见下。

```
 31               12 11 9 8 7 6 5 4 3 2 1 0
+-------------------+----+-+-+-+-+-+-+-+-+-+
|   页表基址高20位   |忽略|G|S|0|A|C|T|U|W|P|
+-------------------+----+-+-+-+-+-+-+-+-+-+
```

说明：

* 页表基址：页表的**物理地址**，需要4KB对齐，所以只需填写高20位
* 忽略：内核可以记录自己需要的信息
* G：对于页目录，这一项不用
* S：页大小，1为4MB，0为4KB；ucore置为0
* A：在上次清零之后，该页是否被访问（读或者写）过，可用于页替换算法的实现
* C：置1则不缓存，否则缓存
* T：置1则缓存写穿，否则写回
* U：置0则页表中任何页面只能内核态访问，否则用户态可能可以访问，还取决于页表项的设置
* W：页面是否可写，但若CR0的WP位置为0，内核总可以写
* P：页面是否存在于内存中

页表项的字段和页目录项十分类似：

```
 31               12 11 9 8 7 6 5 4 3 2 1 0
+-------------------+----+-+-+-+-+-+-+-+-+-+
|   页基地址高20位   |忽略|G|0|D|A|C|T|U|W|P|
+-------------------+----+-+-+-+-+-+-+-+-+-+
```

说明：

- 页基地址：页面的**物理地址**，需要4KB对齐，所以只需填写高20位
- 忽略：内核可以记录自己需要的信息
- G：这一页表项是否是全局项，若被置位，在CR3改变时，相应TLB不被清除，对于内核的页面映射，可以设置此位来优化内核访问内存的性能
- D：在上次清零之后，该页是否被写过，可用于页替换算法的实现
- U：置0则该页面只能内核态访问，否则用户态可以访问
- P：页面是否存在于内存中
- 其余位和页目录项含义相同

另外，当P位清零时，其余位都可供内核使用。这可以用来存放交换分区的一些信息，用于页替换算法的实现。

与参考答案对比，我没有判断`alloc_page`失败的情况，应修复。

## 练习3

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。

与参考答案对比，我在减少和判断页面引用计数时将两个操作分开进行了，在某些情况下可能会有重复释放页面的问题，应修复。