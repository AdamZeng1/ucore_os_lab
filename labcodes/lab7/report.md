# Lab 7

## 知识点

这些是与本实验有关的原理课的知识点：

* 禁用中断的同步方法
* 信号量：实现上与原理课的讲解有细微偏差
* 条件变量、管程
* 哲学家就餐问题

此外，本实验还涉及如下知识点：

无

遗憾的是，如下知识点在原理课中很重要，但本次实验没有很好的对应：

* 纯软件实现的同步方法
* 读者-写者问题
* 死锁
* 进程间通信

## 练习0

首先，需要对之前的代码进行微小的修改：在每一次时钟中断来临时改为调用`run_timer_list`，而不是调用`sched_class_proc_tick`。同时，恢复`sched_class_proc_tick`为`static`。

## 练习1

在实现信号量时，使用到了等待队列`wait_queue_t`。

等待队列实际上就是一个链表，存放了若干等待对象。等待对象`wait_t`实际上就是进程指针和一些标志组成的结构体。等待队列各种操作实际上就是对链表操作的包装。

### 初始化操作

一个信号量维护了其数值以及一个等待队列。

初始化时需要设置信号量的数值，以及初始化等待队列。

### down（P）操作

首先判断数值是否大于0，大于0的话则直接减少1，然后立即返回。否则，将当前进程放入等待队列并运行调度器，调度到其他进程。当再次被调度回来的时候说明进程被唤醒，若等待对象的标志未被修改则进一步说明获得了信号量。等待对象的标志发生了变化，则说明是其他原因唤醒的。无论如何，进程会将自己从等待队列中移除（若还在队列中），本次操作完成。

注意，整个操作过程中要关中断来保护共享变量不被意外修改。

### up（V）操作

这个操作和down操作在某种意义下是对偶的。

首先判断该信号量的等待队列是否为空，为空则将数值增加1然后立即返回。否则，说明有进程在等待此信号量，此时，选取等待队列队首的元素唤醒即可。

同样，整个操作过程中要关中断来保护共享变量不被意外修改。

从上面可以看出，这样的实现保持了信号量的数值大于等于0的性质，这与原理课不同，其他的实现也与原理课的讲解有很大区别。

为了在用户态实现信号量，一种可能的方法是直接复用内核线程的down、up操作的函数，把它们包装成系统调用供用户进程使用。此外，还要加入用户向内核申请、释放一个信号量对象的系统调用。需要注意的是，内核线程的down以及up操作使用信号量结构体的指针作为参数，但系统调用不能这样做，因为出于安全性考虑，用户进程不能持有或间接访问内核的指针。与Lab 8中的打开的文件类似，可为每一个进程维护一个信号量指针数组，由一个进程的多个用户线程共享，创建、down、up或释放操作时都使用数组的下标来进行访问。内核还应做必要的参数检查。

## 练习2

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。

TODO

与参考答案对比，我的实现和参考答案十分一致。

### 能否不基于信号量机制来实现条件变量？

我认为可以，但是需要某种锁。

